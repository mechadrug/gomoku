# 搜索问题

## 搜索问题的形式化

1. 状态空间state space：空间内对象状态(包括位置和其他属性的集合)

2. 初始状态initial state：任意状态都可以是

3. 目标状态：最终想要达成的状态

4. 行动 action：在某一状态下可以采取的行动，包括位置与其他属性的改变

5. 转移模型transition model：给出状态s执行动作a后所产生的状态

6. 动作代价函数action cost function：给出s执行动作a从而转移到状态s·的数值代价

7. 搜索树相关名词解释：

    - 节点：对应状态空间中的一个状态(边->行动；根节点->初始状态)
    - 扩展：查看对于某状态采取行动后所指向的其他状态
    - 生成：对新状态生成子节点
    - 边界：对于当前已扩展状态所有下一步状态的统称
    - 已达：扩展＋未扩展节点的集合的状态(已生成)

7. 最佳优先搜索：

    - "对于每个子节点，如果之前未到达过该子节点，则将其添加到边界；如果到达该子节点的当前路径的代价比之前任何路径都要小，则将其重新添加到边界。":保证了最优搜索算法(不再优化之前的路径，换言之没有冗余搜索，是树搜索)
    - 对抗冗余的方法：1.检测该节点所有路径的代价，并且只保留最优路径，**前提**：内存足够容纳已达状态表；2.对于特定问题不必检查；3.完全回溯与部分回溯消除循环：完全回溯可以顺着指针链检查长循环中是否出现过末端节点(开始检测的节点)但是耗时间；部分回溯则耗时固定但需要其他方法检测长循环

8. 算法的性能：完备性（目标与报错）；代价最优性；时间复杂性和空间复杂性。
    - 空间复杂度：空间大小，对于无限空间可能没有解的情况需要算法完备性良好。
    - 时间复杂度：衡量隐式状态空间的复杂度：1.最优解的深度depth或者动作数；2.任意路径的最大动作数；3.节点的分支因子或者后继节点数。

## 无信息搜索策略(基于最佳优先搜索的改进)

1. BFS：扩展根节点->扩展根节点的**所有**后继节点->循环直到找到目标节点。采取早期目标测试，总是能够返回最短的到目标的路径

    - 早期目标测试：每次生成新节点就立即检测节点是否是目标
    - 后期目标测试：当该节点成为优先队列中优先级最高的节点，才会被弹出并检查
    - 时空复杂度：O(b^d) 分支因子：b，深度：d
    - 评价函数：f(n)->节点的深度

2. dijkstra：在现有路径中**每次**选取代价最小的路径，扩展其边界节点。采取后期目标测试。目的：返回代价更小的节点

    - 算法dijkstra只在扩展节点时测试其是否为目标节点，而不是在生成节点时测试，因此就算到达目标也不一定结束，除非它代价最小
    - 时空复杂度(最坏情况)：O(b^1+[c*/α]取下整数) c*：最优解代价；α：min(每个动作代价)>=O(b^d)
    - 评价函数：f(n)->此节点的代价

3. DFS:对于最长的路径，随机选取下一个方向进行扩展，直到到达边界；到达边界后，此路径停止更新，在剩余最长路径中选择一条路径再进行前面的工作。采取早期目标测试

    - 时间复杂度：O(b^m)
    - 空间复杂度：O(bm) m--树的最大深度
    - 不是代价最优
    - 进化：**深度受限搜索DLS**：对于大于len的路径全部视为不再有后继节点.缺点：对len的选择要求高；十分容易成为不完备算法
    - 超进化：**迭代加深搜索IDS**：循环调用深度受限搜索,从0开始每次的depth+1

4. BS-CSP:解决约束满足问题的回溯搜索。**回溯搜索的核心在于递归地尝试每一种可能的解，并且在发现当前解不满足约束条件时，立即回溯，放弃当前路径，尝试其他路径。**

    - 常常配合剪枝算法一起使用,如：
    - **约束传播**：在选择某个解的组成部分之前，通过传播约束条件提前过滤掉不可能的选择。
    - **最小剩余值启发式**：在选择下一个变量时，优先选择那些取值范围最小的变量，减少递归深度。
    - **AC-3算法**：用于在约束满足问题中提前消除不符合约束的选择。
    - 最坏时间复杂度为O(b^d)，空间复杂度为O(d)

    ```c++
        Backtracking(问题, 当前解):
        if 当前解满足问题的约束:
            返回 当前解
        for 每个可能的选择 in 当前解的扩展:
            if 该选择满足约束:
                将该选择添加到当前解
                递归调用 Backtracking(问题, 当前解)
                如果找到解则返回
                否则，撤销该选择（回溯）
        return 无解
    ```

5. BS-双向搜索：起点和终点同时搜索，知道找到两边评估函数最优解接触的点，并连接成一条最优路径，O(b^0.5d).

## 启发式搜索策略：f=g+h

1. 贪心搜索：f(n)=g(n),只考虑局部最优解，每次选择最优节点进行扩展

2. A*搜索：f(n)=g(n)+h(n)，关键：选择可容许的启发式函数（不一定一致），不会高估到达某个目标的代价，这时算法一定代价最优；h(n)满足三角不等式，即不会出现中间节点使得h(a->b)>=h(a->n)+h(n->b),这时启发式函数是一致的

3. 加权A*搜索：对更偏向路径代价或者目标代价进行加权，使得算法更优先考虑某一项指标，从而达到贪心的效果，节省时空