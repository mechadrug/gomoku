# c++对C语言的基本扩充 #

1. 有字符串常量时需要在前面＋const

2. 内联函数（inline）的用法：在函数声明前面加入inline；
    避免了函数调用的开销，直接将函数体插入调用点。

    *相比宏定义的优点*：在替换文本的基础上提供了类型检查，调试时会被识别为正常函数

    *注意*：递归函数不可以用inline（无法获取实际的函数地址）；复杂函数有可能会被编译器忽略inline

    *类中的内联函数*：看myClass.cpp和myclass.h

3. 带缺省值的形式参数:

    *默认参数*：所有有默认值的形参应该全处于形参表的右边。否则报错

    *不同文件*：为什么只能在头文件（通常）的声明中提供默认值？因为：

        >避免歧义：如果默认参数可以在定义处再次指定，那么在多个源文件（.cpp 文件）中可能会对同一函数产生不同的默认参数值，这样会导致调用时使用哪个默认值的问题。例如，不同的 .cpp 文件会对相同的函数做不同的假设，造成代码的不一致性。>

    *课件似乎有问题？？在不同...*

4. 名空间作用域：

    *写法*：1.`using namespace A` 2.`using A::f`(f是A中的一个变量，A中的其他变量没有被引入) 3.没有引入的名空间或者其中的变量需要`A::x`这样使用

    *无名空间*：限制符号的作用域，使得仅仅在定义他们的翻译单元中可见（如源文件），这样可以避免符号冲突。```namespace {
    int hiddenVariable = 42;  // 仅在此文件中可见
    }```

    *全局命名空间*：未使用namespace定义的成员均为全局命名空间

    *别名与嵌套*：可以在名空间内嵌套名空间，使用`outer::inner::innerfunction`访问，亦可以简化成：`namespace MyNS = MyNamespace::InnerNamespace;`与`MyNS::myFunction();`

5. 动态变量：

    *栈*：在函数内部声明的所有变量都将占用栈内存

    *堆*：程序中未使用的内存，可以在程序运行时用于动态分配内存

    *不同于malloc的new*：`new data-type` 这里的datatype可以是任意数据类型。详细看motivate.cpp;相比于malloc和free函数，new和delete有以下优点：1.适用于对象；2.类型安全，不用手动进行类型转换；3.会初始化分配的内存；4.处理数组可以保证每个元素的构造和析构（初始化？？是什么）

6. 指针与引用(`type *var-name`):

    *指针的值*：代表内存地址的长的十六进制数；不同指针唯一不同是指向变量或常量的数据类型不同

    *`*ip=var`*:ip存放地址，也可以用&var表示；*ip表示值，也可以用var表示。星号相当于将右侧变量的值作为地址取出该地址中的值，&相当于解析出右侧变量的地址。

    *引用与指针不能混淆*：不存在空引用。创建就要初始化(绑定到合法的内存上);一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。

    *三种传参方式的比较*: (1)将变量名作为实参和形参。这时传给形参的是变量的值，传递是单向的。如果在执行函数期间形参的值发生变化，并不传回给实参。因为在调用函数时，形参和实参不是同一个存储单元。// 同 c

    (2) 传递变量的指针。形参是指针变量，实参是一个变量的地址，调用函数时，形参(指针变量)指向实参变量单元。这种通过形参指针可以改变实参的值。// 同 c

    (3) C++提供了 传递变量的引用。形参是引用变量，和实参是一个变量，调用函数时，形参(引用变量)指向实参变量单元。这种通过形参引用可以改变实参的值。

    *PPT第二十五页的解释*：为什么`void f(int*const p)`可以达到和`void f(int& x)`一样的效果：const之后就变成了常量，无法改变该指针指向的对象。引用中的形参也是，只能改变实参。

    *防止函数通过指针和引用类型的形参修改传入的数据*：使用`const type *var-name/&var-name`.

7. 函数重载

    *概念*：函数重载可以用同一个名字定义多个不同的函数，但要求这些函数的参数格式或类型有所不同

    *精确匹配*：传参完全符合函数类型

    *提升匹配*：整型提升：`bool char signed char unsigned char short unsigned short ->int`;浮点提升：`float ->double`;枚举提升

    *标准转换匹配*：如`int ->double`之类的数字类型转换；`const ->非const`之类的指针类型转换 还有数组和函数指针的转换

    *自定义标准匹配*：在类中定义 operator 关键字的类型转换运算符；在类中定义的构造函数，使得它可以从另一种类型转换为该类类型。例：```class MyClass {
    public:
        MyClass(int a) { }  // 从 int 构造 MyClass 的构造函数
    };
    void func(MyClass obj);
    func(10);  // 10 是 int 类型，通过自定义转换匹配，将 int 转换为 MyClass```

8. 基于范围的for(range-based for loop)：
    - 语法：```for (declaration : container) {
    // loop body
    }```

9. auto: 
    - 基本语法`auto variable_name = initialization`
    - 简化了代码；当一个函数返回的类型很复杂，或者返回类型取决于编译时推导的表达式时，auto 非常有用。
    - 必须初始化：auto 变量必须在声明时进行初始化，因为编译器需要根据初始化值推导类型。
    - 引用与指针：auto 可以自动推导引用类型或指针类型，但它不会自动推导出引用。如果需要让 auto 推导为引用类型，必须显式使用引用符号 &。`auto& c = a`
    - const 和 auto：auto 会忽略初始化表达式的 const 限定符，除非显式声明 const auto。如果你想让 auto 推导出 const 类型，需要显式添加 const。`const auto c = a`