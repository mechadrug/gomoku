# 构造函数与析构函数

## 构造函数（在public中）

1. 构造函数：类的特殊成员函数，名字与类名相同，无返回值类型`A(){}`,不用加function-type。**创建对象时**构造函数会被**自动**调用(之后不能再调用构造函数)

2. 默认构造函数：没有任何形式参数的同名函数.[默认.cpp](构造函数与析构函数\默认.cpp)

3. 单独创建动态对象`A*p1=new A;`可以调用任意构造函数,而创建**动态对象数组**时只能调用各个对象的**默认**构造函数.原因:1.内存分配和对象初始化是分开的(提高效率所以编译器规定使用默认);2.数组无法指定参数(不能为每个元素分别传递参数)

4. 可以通过类的构造函数创建一些临时对象

```c++
void f(A a);

f(A(10));
```

1. c++11之后的常量与引用数据成员的初始化标准.[初始化.cpp](构造函数与析构函数\初始化.cpp).并且在成员初始化表中可以初始化多个成员,他们的初始化次序仅取决于他们在类定义中的描述次序而不是在成员初始化表中的次序.

## 析构函数

1. ~<类名>.析构函数没有返回类型,没有参数,不能被重载.在对象消亡时(离开当前作用域或者动态对象被清理)

2. 何时定义析构函数?:额外申请了内存空间,比如释放内存,关闭文件,断开网络连接等;还有比较小的问题,比如指针分配内存处理[point.cpp](构造函数与析构函数\point.cpp);又比如链表实现的栈类pop操作数小于push操作数,则会造成节点空间泄露,所以要在析构函数中归还节点空间[第十三页](E:/111%E5%A4%A7%E4%BA%8C%E4%B8%8A/CPP/2-3%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.pdf)

3. 析构函数的显式调用:暂时归还对象的额外申请资源(比如清空字符串、清空栈...)但是不删除对象.

4. 成员对象初始化和消亡处理的次序:构造函数:先是基类,再是按照**声明顺序**(与构造函数的初始化列表中的顺序无关)执行成员对象的构造函数,最后执行派生类(子类)的构造函数.析构函数:与构造函数完全相反[init-die.cpp](构造函数与析构函数/init-die.cpp)

5. 智能指针

```c++
#include <memory>

class MyClass {
    std::unique_ptr<int[]> data;
public:
    MyClass() : data(new int[100]) {}  // 自动管理内存，无需显式释放
};

```

6. 虚析构函数(略)